#' Render the graph in various formats
#'
#' Using a \code{dgr_graph} object, render the graph in the RStudio Viewer.
#' @param graph a graph object of class \code{dgr_graph}.
#' @param layout a string specifying a layout type to use for node placement in
#'   this rendering. Possible layouts include: \code{nicely}, \code{circle},
#'   \code{tree}, \code{kk}, and \code{fr}.
#' @param output a string specifying the output type; \code{graph} (the default)
#'   renders the graph using the \code{\link{DiagrammeR::grViz}()} function and
#'   \code{visNetwork} renders the graph using the \code{\link{visnetwork}()}
#'   function.
#' @param as_svg an option to render the graph as an SVG document.
#' @param title an optional title for a graph when using
#'   \code{output = "graph"}.
#' @param width an optional parameter for specifying the width of the resulting
#'   graphic in pixels.
#' @param height an optional parameter for specifying the height of the
#'   resulting graphic in pixels.
#' @examples
#' \dontrun{
#' # Render a graph that's a
#' # balanced tree
#' create_graph() %>%
#'   add_balanced_tree(
#'     k = 2, h = 3) %>%
#'   render_graph()
#'
#' # Use the `tree` layout for
#' # better node placement in this
#' # hierarchical graph
#' create_graph() %>%
#'   add_balanced_tree(
#'     k = 2, h = 3) %>%
#'   render_graph(layout = "tree")
#'
#' # Plot the same tree graph but
#' # don't show the node ID values
#' create_graph() %>%
#'   add_balanced_tree(
#'     k = 2, h = 3) %>%
#'   set_node_attr_to_display() %>%
#'   render_graph(layout = "tree")
#'
#' # Create a circle graph
#' create_graph() %>%
#'   add_gnm_graph(
#'     n = 55,
#'     m = 75,
#'     set_seed = 23) %>%
#'   render_graph(
#'     layout = "circle")
#'
#' # Render the graph using the
#' # `visNetwork` output option
#' create_graph() %>%
#'   add_balanced_tree(
#'     k = 2, h = 3) %>%
#'   render_graph(
#'     output = "visNetwork")
#' }
#' @importFrom dplyr select rename mutate filter coalesce left_join
#' @importFrom dplyr pull bind_cols as_tibble as_data_frame
#' @importFrom igraph layout_in_circle layout_with_sugiyama
#' @importFrom igraph layout_with_kk layout_with_fr layout_nicely
#' @importFrom purrr flatten_chr
#' @importFrom tidyr fill
#' @importFrom htmltools browsable HTML
#' @importFrom glue glue
#' @export
dag_render <- function(graph,
                         shortLabel = FALSE,
                         layout = NULL,
                         output = NULL,
                         as_svg = FALSE,
                         title = NULL,
                         width = NULL,
                         height = NULL) {

  ## rename label for use in diagram
  relation = ifelse(is.na(graph$nodes_df$formulaString), " ~ " , " = ") # equal or tilde
  ## short label only implements automatic word wrap
  if(shortLabel){
    graph$nodes_df$label = sapply(strwrap(graph$nodes_df$label, width = 12, simplify = FALSE),paste, collapse = "\n")
    } else {
      graph$nodes_df$label = paste0(graph$nodes_df$description,
                                    "\n",graph$nodes_df$label,
                                    relation,
                                    graph$nodes_df$fullDistLabel)
    }

  ## set global attributes
  graph = graph %>%
    DiagrammeR::add_global_graph_attrs(attr = "layout",
                                       value = "dot",
                                       attr_type = "graph") %>%
    DiagrammeR::add_global_graph_attrs(attr = "fillcolor",
                                       value = "AliceBlue",
                                       attr_type = "node") %>%
    DiagrammeR::add_global_graph_attrs(attr = "style",
                                       value = "filled",
                                       attr_type = "node")%>%
    DiagrammeR::add_global_graph_attrs(attr = "shape",
                                       value = "ellipse",
                                       attr_type = "node") %>%
    DiagrammeR::add_global_graph_attrs(attr = "height",
                                       value = "0.5",
                                       attr_type = "node") %>%
    DiagrammeR::add_global_graph_attrs(attr = "width",
                                       value = "0.9",
                                       attr_type = "node") %>%
    DiagrammeR::add_global_graph_attrs(attr = "fixedsize",
                                       value = "false",
                                       attr_type = "node")  %>%
    DiagrammeR::add_global_graph_attrs(attr = "margin",
                                       value = "0.05,0.05",
                                       attr_type = "node") %>%
    DiagrammeR::add_global_graph_attrs(attr = "color",
                                       value = "gray20",
                                       attr_type = "node")  %>%
    DiagrammeR::add_global_graph_attrs(attr = "color",
                                       value = "gray20",
                                       attr_type = "edge")  %>%
    DiagrammeR::add_global_graph_attrs(attr = "fontcolor",
                                       value = "black",
                                       attr_type = "node") %>%
    DiagrammeR::add_global_graph_attrs(attr = "fontcolor",
                                       value = "black",
                                       attr_type = "edge") %>%
    DiagrammeR::add_global_graph_attrs(attr = "labelloc",
                                       value = "b",
                                       attr_type = "graph") %>%
    DiagrammeR::add_global_graph_attrs(attr = "labeljust",
                                       value = "r",
                                       attr_type = "graph")

  ## update attributes for specific node types
  n_nodes <- nrow(graph$nodes_df)
  graph$nodes_df$fillcolor = rep("aliceblue", n_nodes)
  graph$nodes_df$fillcolor[graph$nodes_df$type == "obs"] = "cadetblue"
  graph$nodes_df$fillcolor[graph$nodes_df$type == "censObs"] = "aliceblue;0.5:cadetblue"


  ##### Code to render plate notation subgraphs when
  ##### there are either intersecting or nested subgraphs

  ## is any node duplicated
  duplicateFlag = anyDuplicated(graph$plate_nodes_df$nodeID)

  while(duplicateFlag > 0){
    duplicatedNodeID = graph$plate_nodes_df$nodeID[duplicateFlag]

    ## get vector of indexID's for node
    indices = graph$plate_nodes_df$indexID[graph$plate_nodes_df$nodeID == duplicatedNodeID]

    ## make new combined plate
    newIndex = max(graph$plate_index_df$indexID) + 1
    newIndexLabel = paste(graph$plate_index_df$indexLabel[indices],collapse = "")
    newIndexDescr = paste(graph$plate_index_df$indexDescription[indices],collapse = "_")
    newIndexDispName = paste0(paste0(graph$plate_index_df$indexDescription[indices]," ",
                                     graph$plate_index_df$indexLabel[indices], collapse = "\\r"),"\\r")
    newRow = data.frame(indexID = newIndex,
                        indexLabel = newIndexLabel,
                        indexDescription = newIndexDescr,
                        indexDisplayName = newIndexDispName,
                        stringsAsFactors = FALSE)
    graph$plate_index_df = dplyr::bind_rows(graph$plate_index_df,newRow)

    ## make nodes point to new plate
    graph$plate_nodes_df = graph$plate_nodes_df %>%
      dplyr::filter(nodeID != duplicatedNodeID) %>%
      dplyr::bind_rows(data.frame(indexID = newIndex, nodeID = duplicatedNodeID))

    ## condition to break out.
    duplicateFlag = anyDuplicated(graph$plate_nodes_df$nodeID)
  }


  ## update attributes for plate notation
  if(nrow(graph$plate_nodes_df) > 0){
    plateDF = dplyr::left_join(graph$plate_nodes_df, graph$plate_index_df) %>%
      dplyr::mutate(clusterName = indexDisplayName) %>%
      select(nodeID, clusterName) %>%
      rename(id = nodeID)
    graph$nodes_df$cluster = dplyr::left_join(graph$nodes_df,plateDF) %>% .$clusterName
  }

  ## correct for fontcolor bug
  graph$nodes_df$fontcolor = "black"


  # Get the name of the function
  fcn_name <- get_calling_fcn()

  # Validation: Graph object is valid
  if (graph_object_valid(graph) == FALSE) {

    emit_error(
      fcn_name = fcn_name,
      reasons = "The graph object is not valid")
  }

  # Create bindings for specific variables
  V1 <- V2 <- x <- y <- attr_type <- value_x <- NULL
  value <- hex <- fillcolor <- new_fillcolor <- NULL

  if (is.null(output)) {
    output <- "graph"
  }

  if (output == "graph") {
    if (!is.null(title)) {

      graph <-
        add_global_graph_attrs(
          graph, "label", title, "graph")

#      graph <-
#        add_global_graph_attrs(
#          graph, "labelloc", "t", "graph")

#      graph <-
#        add_global_graph_attrs(
#          graph, "labeljust", "c", "graph")
#
#     graph <-
#       add_global_graph_attrs(
#         graph, "fontname", "Helvetica", "graph")

#     graph <-
#       add_global_graph_attrs(
#         graph, "fontcolor", "gray30", "graph")
    }

    # If no fillcolor provided, use default; if no default available,
    # use white
    if (nrow(graph$nodes_df) > 0) {
      if (!("fillcolor" %in% colnames(graph$nodes_df))) {
        if ("fillcolor" %in% graph$global_attrs$attr) {

          graph$nodes_df$fillcolor <-
            graph$global_attrs %>%
            dplyr::filter(attr == "fillcolor" & attr_type == "node") %>%
            dplyr::select(value) %>%
            purrr::flatten_chr()
        } else {
          graph$nodes_df$fillcolor <- "white"
        }
      }
    }

    # If fillcolor is available and there are NA values,
    # replace NAs with default color if available
    if (nrow(graph$nodes_df) > 0) {
      if ("fillcolor" %in% colnames(graph$nodes_df)) {
        if ("fillcolor" %in% graph$global_attrs$attr) {

          graph$nodes_df$fillcolor[which(is.na(graph$nodes_df$fillcolor))] <-
            graph$global_attrs[which(graph$global_attrs$attr == "fillcolor"), 2]
        }
      }
    }

    # Translate X11 colors to hexadecimal colors
    if ("fillcolor" %in% colnames(graph$nodes_df)) {

      graph$nodes_df <-
        graph$nodes_df %>%
        dplyr::left_join(
          DiagrammeR::x11_hex() %>%
            dplyr::as_tibble() %>%
            dplyr::mutate(hex = toupper(hex)),
          by = c("fillcolor" = "x11_name")) %>%
        dplyr::mutate(new_fillcolor = dplyr::coalesce(hex, fillcolor)) %>%
        dplyr::select(-fillcolor, -hex) %>%
        dplyr::rename(fillcolor = new_fillcolor)
    }

    # Use adaptive font coloring for nodes that have a fill color
    if (!("fontcolor" %in% colnames(graph$nodes_df)) &
        "fillcolor" %in% colnames(graph$nodes_df)) {

      graph$nodes_df$fontcolor <-
        tibble::tibble(value = graph$nodes_df$fillcolor) %>%
        dplyr::mutate(value_x = contrasting_text_color(background_color = value)) %>%
        dplyr::pull(value_x)
    }

    if (!is.null(layout)) {
      if (layout %in% c("circle", "tree", "kk", "fr", "nicely")) {

        graph <-
          graph %>%
          add_global_graph_attrs(
            attr = "layout",
            value = "neato",
            attr_type = "graph")

        if ("x" %in% colnames(graph$nodes_df)) {
          graph$nodes_df <-
            graph$nodes_df %>%
            dplyr::select(-x)
        }

        if ("y" %in% colnames(graph$nodes_df)) {
          graph$nodes_df <-
            graph$nodes_df %>%
            dplyr::select(-y)
        }

        if (layout == "circle") {
          coords <-
            graph %>%
            to_igraph() %>%
            igraph::layout_in_circle() %>%
            dplyr::as_tibble() %>%
            dplyr::rename(x = V1, y = V2) %>%
            dplyr::mutate(x = x * (((count_nodes(graph) + (0.25 * count_nodes(graph)))) / count_nodes(graph))) %>%
            dplyr::mutate(y = y * (((count_nodes(graph) + (0.25 * count_nodes(graph)))) / count_nodes(graph)))
        }

        if (layout == "tree") {
          coords <-
            (graph %>%
               to_igraph() %>%
               igraph::layout_with_sugiyama())[[2]] %>%
            dplyr::as_tibble() %>%
            dplyr::rename(x = V1, y = V2)
        }

        if (layout == "kk") {
          coords <-
            graph %>%
            to_igraph() %>%
            igraph::layout_with_kk() %>%
            dplyr::as_tibble() %>%
            dplyr::rename(x = V1, y = V2)
        }

        if (layout == "fr") {
          coords <-
            graph %>%
            to_igraph() %>%
            igraph::layout_with_fr() %>%
            dplyr::as_tibble() %>%
            dplyr::rename(x = V1, y = V2)
        }

        if (layout == "nicely") {
          coords <-
            graph %>%
            to_igraph() %>%
            igraph::layout_nicely() %>%
            dplyr::as_tibble() %>%
            dplyr::rename(x = V1, y = V2)
        }

        # Bind (x, y) coordinates to the graph's
        # internal NDF
        graph$nodes_df <-
          graph$nodes_df %>%
          dplyr::bind_cols(coords)
      }
    }


    if (("image" %in% colnames(graph %>% DiagrammeR::get_node_df()) ||
         "fa_icon" %in% colnames(graph %>% DiagrammeR::get_node_df()) ||
         as_svg) &
        requireNamespace("DiagrammeRsvg", quietly = TRUE)) {

      # Stop function if `DiagrammeRsvg` package is not available
      if (!("DiagrammeRsvg" %in%
            rownames(utils::installed.packages()))) {

        emit_error(
          fcn_name = fcn_name,
          reasons = c(
            "Cannot currently render the graph to an SVG",
            "please install the `DiagrammeRsvg` package and retry",
            "pkg installed using `install.packages('DiagrammeRsvg')`",
            "otherwise, set `as_svg = FALSE`"))
      }

      # Generate DOT code
      dot_code <- DiagrammeR::generate_dot(graph)

      # Get a vector of SVG lines
      svg_vec <-
        strsplit(DiagrammeRsvg::export_svg(
          DiagrammeR::grViz(diagram = dot_code)), "\n") %>%
        unlist()

      # Get a tibble of SVG data
      svg_tbl <- get_svg_tbl(svg_vec)

      svg_lines <-
        "<svg display=\"block\" margin=\"0 auto\" position=\"absolute\" width=\"100%\" height=\"100%\""

      svg_line_no <- svg_tbl %>%
        dplyr::filter(type == "svg") %>%
        dplyr::pull(index)

      # Modify <svg> attrs
      svg_vec[svg_line_no] <- svg_lines

      if ("image" %in% colnames(graph %>% DiagrammeR::get_node_df())) {

        node_id_images <-
          graph %>%
          DiagrammeR::get_node_df() %>%
          dplyr::select(id, image) %>%
          dplyr::filter(image != "") %>%
          dplyr::pull(id)

        filter_lines <-
          graph %>%
          DiagrammeR::get_node_df() %>%
          dplyr::select(id, image) %>%
          dplyr::filter(image != "") %>%
          dplyr::mutate(filter_lines = as.character(glue::glue("<filter id=\"{id}\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\"><feImage xlink:href=\"{image}\"/></filter>"))) %>%
          dplyr::pull(filter_lines) %>%
          paste(collapse = "\n")

        filter_shape_refs <- as.character(glue::glue(" filter=\"url(#{node_id_images})\" "))

        svg_shape_nos <-
          svg_tbl %>%
          dplyr::filter(node_id %in% node_id_images) %>%
          dplyr::filter(type == "node_block") %>%
          dplyr::pull(index)

        svg_shape_nos <- svg_shape_nos + 3
        svg_text_nos <- svg_shape_nos + 1

        # Modify shape lines
        for (i in seq(node_id_images)) {

          svg_vec[svg_shape_nos[i]] <-
            sub(" ", paste0(filter_shape_refs[i]), svg_vec[svg_shape_nos[i]])

          svg_vec[svg_text_nos[i]] <- ""
        }

        # Add in <filter> lines
        svg_vec[svg_line_no + 1] <-
          paste0(svg_vec[svg_line_no + 1], "\n\n", filter_lines, "\n")
      }

      if ("fa_icon" %in% colnames(graph %>% DiagrammeR::get_node_df())) {

        # Stop function if `DiagrammeRsvg` package is not available
        if (!("fontawesome" %in%
              rownames(utils::installed.packages()))) {

          emit_error(
            fcn_name = fcn_name,
            reasons = c(
              "Cannot currently render FontAwesome icons",
              "please install the `fontawesome` package and retry",
              "pkg installed using `devtools::install_github('rstudio/fontawesome')`"))
        }

        node_id_fa <-
          graph %>%
          DiagrammeR::get_node_df() %>%
          dplyr::select(id, fa_icon) %>%
          dplyr::filter(fa_icon != "") %>%
          dplyr::filter(!is.na(fa_icon)) %>%
          dplyr::mutate(fa_uri = NA_character_)

        node_id_svg <-
          node_id_fa %>%
          dplyr::pull(id)

        for (i in seq(nrow(node_id_fa))) {

          random_name <- paste(sample(letters[1:10], 10), collapse = "")
          tmp_svg_file <- paste0(random_name, ".svg")

          fa_icon <- node_id_fa[i, ]$fa_icon
          id <- node_id_fa[i, ]$id

          writeLines(fontawesome::fa(fa_icon), tmp_svg_file)

          svg_uri <- get_image_uri(tmp_svg_file)

          file.remove(tmp_svg_file)

          node_id_fa[i, "fa_uri"] <-
            as.character(glue::glue("<filter id=\"{id}\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\"><feImage xlink:href=\"{svg_uri}\"/></filter>"))
        }

        filter_lines <-
          node_id_fa %>%
          dplyr::pull(fa_uri) %>%
          paste(collapse = "\n")

        filter_shape_refs <- as.character(glue::glue(" filter=\"url(#{node_id_svg})\" "))

        svg_shape_nos <-
          svg_tbl %>%
          dplyr::filter(node_id %in% node_id_svg) %>%
          dplyr::filter(type == "node_block") %>%
          dplyr::pull(index)

        svg_shape_nos <- svg_shape_nos + 3
        svg_text_nos <- svg_shape_nos + 1

        # Modify shape lines
        for (i in seq(node_id_svg)) {

          svg_vec[svg_shape_nos[i]] <-
            sub(" ", paste0(filter_shape_refs[i]), svg_vec[svg_shape_nos[i]])

          svg_vec[svg_text_nos[i]] <- ""
        }

        # Add in <filter> lines
        svg_vec[svg_line_no + 1] <-
          paste0(svg_vec[svg_line_no + 1], "\n\n", filter_lines, "\n")
      }

      svg_vec_1 <- paste(svg_vec, collapse = "\n")

      display <- htmltools::browsable(htmltools::HTML(svg_vec_1))

    } else {

      # Generate DOT code
      dot_code <- DiagrammeR::generate_dot(graph)

      # Generate a `DiagrammeR::grViz` object
      grVizObject <-
        DiagrammeR::grViz(
          diagram = dot_code,
          width = width,
          height = height)

      display <- grVizObject
    }

    display

  } else if (output == "visNetwork") {
    visnetwork(graph)
  }
}

